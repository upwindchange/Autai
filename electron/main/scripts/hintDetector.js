
// Combined HintDetector with CSS Selector Generator
// Generated by buildHintDetector.js
(function() {
  "use strict";
  
  // CSS Selector Generator Library (UMD build)
  !function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.CssSelectorGenerator=e():t.CssSelectorGenerator=e()}(self,(()=>(()=>{"use strict";var t={d:(e,n)=>{for(var r in n)t.o(n,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};function n(t){return"object"==typeof t&&null!==t&&t.nodeType===Node.ELEMENT_NODE}t.r(e),t.d(e,{default:()=>Q,getCssSelector:()=>K});const r={NONE:"",DESCENDANT:" ",CHILD:" > "},o={id:"id",class:"class",tag:"tag",attribute:"attribute",nthchild:"nthchild",nthoftype:"nthoftype"},i="CssSelectorGenerator";function c(t="unknown problem",...e){console.warn(`${i}: ${t}`,...e)}const u={selectors:[o.id,o.class,o.tag,o.attribute],includeTag:!1,whitelist:[],blacklist:[],combineWithinSelector:!0,combineBetweenSelectors:!0,root:null,maxCombinations:Number.POSITIVE_INFINITY,maxCandidates:Number.POSITIVE_INFINITY};function s(t){return t instanceof RegExp}function a(t){return["string","function"].includes(typeof t)||s(t)}function l(t){return Array.isArray(t)?t.filter(a):[]}function f(t){const e=[Node.DOCUMENT_NODE,Node.DOCUMENT_FRAGMENT_NODE,Node.ELEMENT_NODE];return function(t){return t instanceof Node}(t)&&e.includes(t.nodeType)}function d(t,e){if(f(t))return t.contains(e)||c("element root mismatch","Provided root does not contain the element. This will most likely result in producing a fallback selector using element's real root node. If you plan to use the selector using provided root (e.g. `root.querySelector`), it will not work as intended."),t;const n=e.getRootNode({composed:!1});return f(n)?(n!==document&&c("shadow root inferred","You did not provide a root and the element is a child of Shadow DOM. This will produce a selector using ShadowRoot as a root. If you plan to use the selector using document as a root (e.g. `document.querySelector`), it will not work as intended."),n):S(e)}function m(t){return"number"==typeof t?t:Number.POSITIVE_INFINITY}function p(t=[]){const[e=[],...n]=t;return 0===n.length?e:n.reduce(((t,e)=>t.filter((t=>e.includes(t)))),e)}function g(t){return[].concat(...t)}function h(t){const e=t.map((t=>{if(s(t))return e=>t.test(e);if("function"==typeof t)return e=>{const n=t(e);return"boolean"!=typeof n?(c("pattern matcher function invalid","Provided pattern matching function does not return boolean. It's result will be ignored.",t),!1):n};if("string"==typeof t){const e=new RegExp("^"+t.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".+")+"$");return t=>e.test(t)}return c("pattern matcher invalid","Pattern matching only accepts strings, regular expressions and/or functions. This item is invalid and will be ignored.",t),()=>!1}));return t=>e.some((e=>e(t)))}function b(t,e,n){const r=Array.from(d(n,t[0]).querySelectorAll(e));return r.length===t.length&&t.every((t=>r.includes(t)))}function y(t,e){e=null!=e?e:S(t);const r=[];let o=t;for(;n(o)&&o!==e;)r.push(o),o=o.parentElement;return r}function N(t,e){return p(t.map((t=>y(t,e))))}function S(t){return t.ownerDocument.querySelector(":root")}const E=", ",v=new RegExp(["^$","\\s"].join("|")),w=new RegExp(["^$"].join("|")),I=[o.nthoftype,o.tag,o.id,o.class,o.attribute,o.nthchild],T=h(["class","id","ng-*"]);function O({name:t}){return`[${t}]`}function C({name:t,value:e}){return`[${t}='${e}']`}function x({nodeName:t,nodeValue:e}){return{name:Y(t),value:Y(null!=e?e:void 0)}}function j(t){const e=Array.from(t.attributes).filter((e=>function({nodeName:t,nodeValue:e},n){const r=n.tagName.toLowerCase();return!(["input","option"].includes(r)&&"value"===t||"src"===t&&(null==e?void 0:e.startsWith("data:"))||T(t))}(e,t))).map(x);return[...e.map(O),...e.map(C)]}function A(t){var e;return(null!==(e=t.getAttribute("class"))&&void 0!==e?e:"").trim().split(/\s+/).filter((t=>!w.test(t))).map((t=>`.${Y(t)}`))}function $(t){var e;const n=null!==(e=t.getAttribute("id"))&&void 0!==e?e:"",r=`#${Y(n)}`,o=t.getRootNode({composed:!1});return!v.test(n)&&b([t],r,o)?[r]:[]}function D(t){const e=t.parentNode;if(e){const r=Array.from(e.childNodes).filter(n).indexOf(t);if(r>-1)return[`:nth-child(${String(r+1)})`]}return[]}function R(t){return[Y(t.tagName.toLowerCase())]}function P(t){const e=[...new Set(g(t.map(R)))];return 0===e.length||e.length>1?[]:[e[0]]}function _(t){const e=P([t])[0],n=t.parentElement;if(n){const r=Array.from(n.children).filter((t=>t.tagName.toLowerCase()===e)),o=r.indexOf(t);if(o>-1)return[`${e}:nth-of-type(${String(o+1)})`]}return[]}function k(t=[],{maxResults:e=Number.POSITIVE_INFINITY}={}){return Array.from(function*(t=[],{maxResults:e=Number.POSITIVE_INFINITY}={}){let n=0,r=M(1);for(;r.length<=t.length&&n<e;){n+=1;const e=r.map((e=>t[e]));yield e,r=L(r,t.length-1)}}(t,{maxResults:e}))}function L(t=[],e=0){const n=t.length;if(0===n)return[];const r=[...t];r[n-1]+=1;for(let t=n-1;t>=0;t--)if(r[t]>e){if(0===t)return M(n+1);r[t-1]++,r[t]=r[t-1]+1}return r[n-1]>e?M(n+1):r}function M(t=1){return Array.from(Array(t).keys())}const V=":".charCodeAt(0).toString(16).toUpperCase(),F=/[ !"#$%&'()\[\]{|}<>*+,./;=?@^`~\\]/;function Y(t=""){return CSS?CSS.escape(t):function(t=""){return t.split("").map((t=>":"===t?`\\${V} `:F.test(t)?`\\${t}`:escape(t).replace(/%/g,"\\"))).join("")}(t)}const W={tag:P,id:function(t){return 0===t.length||t.length>1?[]:$(t[0])},class:function(t){return p(t.map(A))},attribute:function(t){return p(t.map(j))},nthchild:function(t){return p(t.map(D))},nthoftype:function(t){return p(t.map(_))}},q={tag:R,id:$,class:A,attribute:j,nthchild:D,nthoftype:_};function B(t){return t.includes(o.tag)||t.includes(o.nthoftype)?[...t]:[...t,o.tag]}function G(t={}){const e=[...I];return t[o.tag]&&t[o.nthoftype]&&e.splice(e.indexOf(o.tag),1),e.map((e=>{return(r=t)[n=e]?r[n].join(""):"";var n,r})).join("")}function H(t,e,n="",o){const i=function(t,e){return""===e?t:function(t,e){return[...t.map((t=>e+r.DESCENDANT+t)),...t.map((t=>e+r.CHILD+t))]}(t,e)}(function(t,e,n){const r=function(t,e){const{blacklist:n,whitelist:r,combineWithinSelector:o,maxCombinations:i}=e,c=h(n),u=h(r);return function(t){const{selectors:e,includeTag:n}=t,r=[...e];return n&&!r.includes("tag")&&r.push("tag"),r}(e).reduce(((e,n)=>{const r=function(t,e){return(0,W[e])(t)}(t,n),s=function(t=[],e,n){return t.filter((t=>n(t)||!e(t)))}(r,c,u),a=function(t=[],e){return t.sort(((t,n)=>{const r=e(t),o=e(n);return r&&!o?-1:!r&&o?1:0}))}(s,u);return e[n]=o?k(a,{maxResults:i}):a.map((t=>[t])),e}),{})}(t,n),o=function(t,e){return function(t){const{selectors:e,combineBetweenSelectors:n,includeTag:r,maxCandidates:o}=t,i=n?k(e,{maxResults:o}):e.map((t=>[t]));return r?i.map(B):i}(e).map((e=>function(t,e){const n={};return t.forEach((t=>{const r=e[t];r&&r.length>0&&(n[t]=r)})),function(t={}){let e=[];return Object.entries(t).forEach((([t,n])=>{e=n.flatMap((n=>0===e.length?[{[t]:n}]:e.map((e=>Object.assign(Object.assign({},e),{[t]:n})))))})),e}(n).map(G)}(e,t))).filter((t=>t.length>0))}(r,n),i=g(o);return[...new Set(i)]}(t,0,o),n);for(const n of i)if(b(t,n,e))return n;return null}function U(t){return{value:t,include:!1}}function z({selectors:t,operator:e}){let n=[...I];t[o.tag]&&t[o.nthoftype]&&(n=n.filter((t=>t!==o.tag)));let r="";return n.forEach((e=>{var n;(null!==(n=t[e])&&void 0!==n?n:[]).forEach((({value:t,include:e})=>{e&&(r+=t)}))})),e+r}function J(t){return[":root",...y(t).reverse().map((t=>{const e=function(t,e,n=r.NONE){const o={};return e.forEach((e=>{Reflect.set(o,e,function(t,e){return q[e](t)}(t,e).map(U))})),{element:t,operator:n,selectors:o}}(t,[o.nthchild],r.CHILD);return e.selectors.nthchild.forEach((t=>{t.include=!0})),e})).map(z)].join("")}function K(t,e={}){var r;const i=function(t){(t instanceof NodeList||t instanceof HTMLCollection)&&(t=Array.from(t));const e=(Array.isArray(t)?t:[t]).filter(n);return[...new Set(e)]}(t),c=function(t,e={}){const n=Object.assign(Object.assign({},u),e);return{selectors:(r=n.selectors,Array.isArray(r)?r.filter((t=>{return e=o,n=t,Object.values(e).includes(n);var e,n})):[]),whitelist:l(n.whitelist),blacklist:l(n.blacklist),root:d(n.root,t),combineWithinSelector:!!n.combineWithinSelector,combineBetweenSelectors:!!n.combineBetweenSelectors,includeTag:!!n.includeTag,maxCombinations:m(n.maxCombinations),maxCandidates:m(n.maxCandidates)};var r}(i[0],e),s=null!==(r=c.root)&&void 0!==r?r:S(i[0]);let a="",f=s;function p(){return function(t,e,n="",r){if(0===t.length)return null;const o=[t.length>1?t:[],...N(t,e).map((t=>[t]))];for(const t of o){const o=H(t,e,n,r);if(o)return{foundElements:t,selector:o}}return null}(i,f,a,c)}let g=p();for(;g;){const{foundElements:t,selector:e}=g;if(b(i,e,s))return e;f=t[0],a=e,g=p()}return i.length>1?i.map((t=>K(t,c))).join(E):function(t){return t.map(J).join(E)}(i)}const Q=K;return e})()));
  
  // Make getCssSelector available in the current scope
  const getCssSelector = (typeof window !== 'undefined' && window.CssSelectorGenerator) 
    ? window.CssSelectorGenerator.getCssSelector 
    : (typeof globalThis !== 'undefined' && globalThis.CssSelectorGenerator)
    ? globalThis.CssSelectorGenerator.getCssSelector
    : undefined;
  
  // Hint Detector Script (compiled from TypeScript)
  "use strict";
// TypeScript implementation of hint detection for browser automation
// Based on Vimium-C and Vimium hint detection algorithms
// Constants
const HINT_CONTAINER_ID = "autai-hint-container";
const ANGULAR_CLICK_ATTRIBUTES = [
    "ng-click",
    "data-ng-click",
    "x-ng-click",
    "ng:click",
    "data-ng:click",
    "x-ng:click",
    "ng_click",
    "data-ng_click",
    "x-ng_click",
];
const CLICKABLE_ROLES = [
    "button",
    "tab",
    "link",
    "checkbox",
    "menuitem",
    "menuitemcheckbox",
    "menuitemradio",
    "radio",
];
// Type guards
function isHTMLInputElement(el) {
    return el.tagName.toLowerCase() === "input";
}
function isHTMLTextAreaElement(el) {
    return el.tagName.toLowerCase() === "textarea";
}
function isHTMLSelectElement(el) {
    return el.tagName.toLowerCase() === "select";
}
function isHTMLDetailsElement(el) {
    return el.tagName.toLowerCase() === "details";
}
function _isHTMLAreaElement(el) {
    return el.tagName.toLowerCase() === "area";
}
function isHTMLImageElement(el) {
    return el.tagName.toLowerCase() === "img";
}
function isHTMLLabelElement(el) {
    return el.tagName.toLowerCase() === "label";
}
// Helper functions
function isVisible(element, checkViewport = true) {
    const rect = element.getBoundingClientRect();
    const style = window.getComputedStyle(element);
    // Check if element has dimensions and is not hidden by CSS
    if (rect.width <= 0 ||
        rect.height <= 0 ||
        style.visibility === "hidden" ||
        style.display === "none" ||
        parseFloat(style.opacity) <= 0) {
        return false;
    }
    // Check viewport constraints if requested
    if (checkViewport) {
        if (rect.bottom <= 0 ||
            rect.top >= window.innerHeight ||
            rect.right <= 0 ||
            rect.left >= window.innerWidth) {
            return false;
        }
    }
    // Check if element is actually visible (not just in DOM)
    const rects = element.getClientRects();
    if (rects.length === 0)
        return false;
    // Check if any rect has actual area
    for (const r of Array.from(rects)) {
        if (r.width > 0 && r.height > 0) {
            return true;
        }
    }
    return false;
}
// Get all elements including shadow DOM
function getAllElements(root, elements = []) {
    const children = root.querySelectorAll("*");
    for (const element of Array.from(children)) {
        elements.push(element);
        if (element.shadowRoot) {
            getAllElements(element.shadowRoot, elements);
        }
    }
    return elements;
}
// Check if element is scrollable
function isScrollableElement(element) {
    const style = window.getComputedStyle(element);
    const overflowY = style.overflowY;
    const overflowX = style.overflowX;
    return ((element.scrollHeight > element.clientHeight &&
        ["auto", "scroll"].includes(overflowY)) ||
        (element.scrollWidth > element.clientWidth &&
            ["auto", "scroll"].includes(overflowX)));
}
function hasAngularClickHandler(element) {
    return ANGULAR_CLICK_ATTRIBUTES.some((attr) => element.hasAttribute(attr));
}
function hasJsAction(element) {
    if (!element.hasAttribute("jsaction"))
        return false;
    const jsaction = element.getAttribute("jsaction") || "";
    const rules = jsaction.split(";");
    for (const rule of rules) {
        const parts = rule.trim().split(":");
        if (parts.length === 1 || (parts.length === 2 && parts[0] === "click")) {
            const actionParts = (parts.length === 1 ? parts[0] : parts[1])
                .trim()
                .split(".");
            if (actionParts[0] !== "none" &&
                actionParts[actionParts.length - 1] !== "_") {
                return true;
            }
        }
    }
    return false;
}
function isInteractable(element) {
    const tagName = element.tagName.toLowerCase();
    const style = window.getComputedStyle(element);
    let clickable = false;
    let reason = null;
    let possibleFalsePositive = false;
    let secondClassCitizen = false;
    // Check aria-disabled
    const ariaDisabled = element.getAttribute("aria-disabled");
    if (ariaDisabled && ["", "true"].includes(ariaDisabled.toLowerCase())) {
        return {
            clickable: false,
            reason: null,
            possibleFalsePositive: false,
            secondClassCitizen: false,
        };
    }
    // Native clickable elements
    switch (tagName) {
        case "a":
            clickable = true;
            break;
        case "button":
            clickable = !element.disabled;
            break;
        case "textarea": {
            const textarea = element;
            clickable = !textarea.disabled && !textarea.readOnly;
            break;
        }
        case "input": {
            const input = element;
            clickable =
                input.type !== "hidden" &&
                    !input.disabled &&
                    !(input.readOnly &&
                        ["text", "search", "email", "url", "tel", "password"].includes(input.type));
            break;
        }
        case "select":
            clickable = !element.disabled;
            break;
        case "label": {
            const label = element;
            clickable =
                label.control != null && !label.control.disabled;
            break;
        }
        case "img":
            clickable = ["zoom-in", "zoom-out"].includes(style.cursor);
            break;
        case "details":
            clickable = true;
            reason = "Open/Close";
            break;
        case "object":
        case "embed":
            clickable = true;
            break;
        case "body":
            // Special handling for body element
            if (element === document.body) {
                // Frame focusing - check if this is a focusable frame
                if (window.innerWidth > 3 &&
                    window.innerHeight > 3 &&
                    document.body.tagName.toLowerCase() !== "frameset") {
                    // Check if we're in an iframe that can be focused
                    if (window !== window.top) {
                        clickable = true;
                        reason = "Frame";
                    }
                    else if (isScrollableElement(element)) {
                        clickable = true;
                        reason = "Scroll";
                    }
                }
            }
            break;
        case "div":
        case "ol":
        case "ul":
            // Scrollable containers
            if (isScrollableElement(element)) {
                clickable = true;
                reason = "Scroll";
            }
            break;
    }
    // Check for event handlers
    if (!clickable) {
        clickable =
            element.hasAttribute("onclick") ||
                hasAngularClickHandler(element) ||
                hasJsAction(element);
    }
    // Check role attribute
    if (!clickable) {
        const role = element.getAttribute("role");
        if (role && CLICKABLE_ROLES.includes(role.toLowerCase())) {
            clickable = true;
        }
    }
    // Check contentEditable
    if (!clickable) {
        const contentEditable = element.getAttribute("contentEditable");
        if (contentEditable &&
            ["", "contenteditable", "true"].includes(contentEditable.toLowerCase())) {
            clickable = true;
        }
    }
    // Check class name for button-like classes
    if (!clickable) {
        const className = element.getAttribute("class") || "";
        if (className.toLowerCase().includes("button")) {
            clickable = true;
            possibleFalsePositive = true;
        }
    }
    // Check cursor style for clickable appearance
    if (!clickable) {
        const cursor = style.cursor || "";
        if (["pointer", "zoom-in", "zoom-out"].includes(cursor)) {
            clickable = true;
            possibleFalsePositive = true;
        }
    }
    // Check tabindex
    if (!clickable) {
        const tabIndexStr = element.getAttribute("tabindex");
        if (tabIndexStr) {
            const tabIndex = parseInt(tabIndexStr);
            if (!isNaN(tabIndex) && tabIndex >= 0) {
                clickable = true;
                secondClassCitizen = true;
            }
        }
    }
    return { clickable, reason, possibleFalsePositive, secondClassCitizen };
}
function getLinkText(element) {
    const tagName = element.tagName.toLowerCase();
    let linkText = "";
    if (isHTMLInputElement(element)) {
        if (element.labels && element.labels.length > 0) {
            linkText = element.labels[0].textContent?.trim() || "";
            if (linkText.endsWith(":")) {
                linkText = linkText.slice(0, -1);
            }
        }
        else if (element.type === "file") {
            linkText = "Choose File";
        }
        else if (element.type !== "password") {
            linkText = element.value || element.placeholder || "";
        }
    }
    else if (tagName === "a" && !element.textContent?.trim()) {
        const img = element.querySelector("img");
        if (img) {
            linkText = img.alt || img.title || "";
        }
    }
    else if (element.textContent) {
        linkText = element.textContent.slice(0, 256);
    }
    else if (element.hasAttribute("title")) {
        linkText = element.getAttribute("title") || "";
    }
    else {
        linkText = element.innerHTML.slice(0, 256);
    }
    return linkText.trim();
}
// Helper function to compare rectangles
function areRectsEqual(rect1, rect2, includeSize = false) {
    const positionMatch = Math.abs(rect1.top - rect2.top) < 1 &&
        Math.abs(rect1.left - rect2.left) < 1;
    if (!includeSize)
        return positionMatch;
    return (positionMatch &&
        Math.abs(rect1.width - rect2.width) < 1 &&
        Math.abs(rect1.height - rect2.height) < 1);
}
// Helper function to find element by rectangle
function findElementByRect(elements, targetRect, includeSize = false) {
    return elements.find((el) => {
        const rect = el.getBoundingClientRect();
        return areRectsEqual(rect, targetRect, includeSize);
    });
}
// Helper function to evaluate XPath
function evaluateXPath(xpath) {
    const result = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
    return result.singleNodeValue;
}
// Generate XPath for an element
function getXPath(element) {
    if (!element)
        return null;
    // Handle special cases
    if (element.id) {
        return `//*[@id="${element.id}"]`;
    }
    // Build path from element to root
    const segments = [];
    let current = element;
    while (current && current.nodeType === Node.ELEMENT_NODE) {
        let index = 1;
        let sibling = current.previousSibling;
        // Count preceding siblings of the same tag name
        while (sibling) {
            if (sibling.nodeType === Node.ELEMENT_NODE &&
                sibling.tagName === current.tagName) {
                index++;
            }
            sibling = sibling.previousSibling;
        }
        const tagName = current.tagName.toLowerCase();
        const segment = tagName + "[" + index + "]";
        segments.unshift(segment);
        // Stop at document root or shadow root
        if (current.parentNode &&
            current.parentNode.nodeType === Node.DOCUMENT_NODE) {
            break;
        }
        current = current.parentElement;
    }
    const xpath = segments.length ? "/" + segments.join("/") : null;
    if (!xpath) {
        console.warn(`[HintDetector] Failed to generate XPath for element:`, element);
    }
    return xpath;
}
// Helper function to dispatch input events
function dispatchInputEvents(element) {
    element.dispatchEvent(new Event("input", { bubbles: true }));
    element.dispatchEvent(new Event("change", { bubbles: true }));
}
// Safe wrapper for CSS selector generation
function generateCssSelector(element) {
    try {
        if (typeof getCssSelector === "function") {
            return getCssSelector(element);
        }
    }
    catch (error) {
        console.warn("[HintDetector] Failed to generate CSS selector:", error);
    }
    // Return empty string if CSS selector generation fails
    // XPath will be used as the primary identifier
    return "";
}
// Create hint marker overlay container
function createHintContainer() {
    let container = document.getElementById(HINT_CONTAINER_ID);
    if (container) {
        container.remove();
    }
    container = document.createElement("div");
    container.id = HINT_CONTAINER_ID;
    container.style.cssText = `
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    pointer-events: none !important;
    z-index: 2147483647 !important;
    isolation: isolate !important;
  `;
    document.documentElement.appendChild(container);
    return container;
}
// Clear existing hint markers
function clearHints() {
    const container = document.getElementById(HINT_CONTAINER_ID);
    if (container) {
        container.innerHTML = "";
    }
}
// Execute appropriate action on element
function executeClickAction(element) {
    const tagName = element.tagName;
    if (isHTMLDetailsElement(element)) {
        console.log(`[HintDetector] Toggling DETAILS element open state`);
        element.open = !element.open;
    }
    else if (isHTMLInputElement(element) ||
        isHTMLTextAreaElement(element) ||
        isHTMLSelectElement(element)) {
        console.log(`[HintDetector] Focusing ${tagName} element`);
        element.focus();
    }
    else {
        console.log(`[HintDetector] Clicking ${tagName} element`);
        element.click();
    }
}
// Determine element type for AI understanding
function determineElementType(hint) {
    if (hint.href && hint.tagName === "a")
        return "link";
    if (hint.tagName === "button")
        return "button";
    if (hint.tagName === "input")
        return "input";
    if (hint.tagName === "select")
        return "select";
    if (hint.tagName === "textarea")
        return "textarea";
    if (hint.reason === "Scroll")
        return "scrollable";
    if (hint.reason === "Frame")
        return "frame";
    if (hint.reason === "Open/Close")
        return "details";
    return "interactive";
}
// Main hint detection function
function detectHints(viewportOnly = true) {
    const hints = [];
    const allElements = getAllElements(document.documentElement);
    // First pass: collect all hints
    allElements.forEach((element) => {
        if (!isVisible(element, viewportOnly))
            return;
        const interactInfo = isInteractable(element);
        if (!interactInfo.clickable)
            return;
        const rect = element.getBoundingClientRect();
        const linkText = getLinkText(element);
        // Handle image maps
        if (isHTMLImageElement(element)) {
            const mapName = element.getAttribute("usemap");
            if (mapName) {
                const map = document.querySelector('map[name="' + mapName.replace(/^#/, "") + '"]');
                if (map) {
                    const areas = map.getElementsByTagName("area");
                    for (const area of Array.from(areas)) {
                        const areaRect = area.getBoundingClientRect();
                        if (areaRect.width > 0 && areaRect.height > 0) {
                            hints.push({
                                rect: {
                                    top: areaRect.top,
                                    left: areaRect.left,
                                    width: areaRect.width,
                                    height: areaRect.height,
                                    right: areaRect.right,
                                    bottom: areaRect.bottom,
                                },
                                linkText: area.alt || area.title || "Area",
                                tagName: "area",
                                href: area.href || null,
                                reason: interactInfo.reason,
                                xpath: getXPath(area),
                                selector: generateCssSelector(area),
                                possibleFalsePositive: false,
                                secondClassCitizen: false,
                            });
                        }
                    }
                    return; // Skip the image itself
                }
            }
        }
        hints.push({
            rect: {
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height,
                right: rect.right,
                bottom: rect.bottom,
            },
            linkText,
            tagName: element.tagName.toLowerCase(),
            href: element.href || null,
            reason: interactInfo.reason,
            xpath: getXPath(element),
            selector: generateCssSelector(element),
            possibleFalsePositive: interactInfo.possibleFalsePositive,
            secondClassCitizen: interactInfo.secondClassCitizen,
        });
    });
    // Filter out false positives and duplicates
    const filteredHints = hints.filter((hint, index) => {
        if (!hint.possibleFalsePositive)
            return true;
        // Check if any descendant in nearby hints is clickable
        const lookbackWindow = 6;
        const start = Math.max(0, index - lookbackWindow);
        for (let i = start; i < index; i++) {
            const candidateElement = findElementByRect(allElements, hints[i].rect);
            if (candidateElement) {
                let candidateDescendant = candidateElement;
                // Check up to 3 levels of ancestry
                for (let j = 0; j < 3; j++) {
                    candidateDescendant = candidateDescendant?.parentElement || null;
                    const currentElement = findElementByRect(allElements, hint.rect);
                    if (candidateDescendant === currentElement) {
                        return false; // This is a false positive
                    }
                }
            }
        }
        return true;
    });
    // Remove duplicate hints for label controls
    const labelledElements = new Set();
    const deduplicatedHints = filteredHints.filter((hint) => {
        if (hint.tagName === "label") {
            const element = findElementByRect(allElements, hint.rect);
            if (element && isHTMLLabelElement(element) && element.control) {
                const controlId = element.control.id || String(element.control);
                if (labelledElements.has(controlId)) {
                    return false;
                }
                labelledElements.add(controlId);
            }
        }
        return true;
    });
    // Log statistics about XPath generation
    const validXPaths = deduplicatedHints.filter((h) => h.xpath).length;
    console.log(`[HintDetector] Detected ${deduplicatedHints.length} hints, ${validXPaths} with valid XPaths (${Math.round((validXPaths / deduplicatedHints.length) * 100)}%)`);
    return deduplicatedHints;
}
// Display hint markers
function showHints() {
    clearHints();
    const container = createHintContainer();
    // Use cached elements if available, otherwise generate new ones
    if (!cachedElements || cacheViewportOnly !== true) {
        console.log("[HintDetector] No cached elements for viewport, generating new hints");
        getInteractableElements(true); // This will populate the cache
    }
    // Filter cached elements to only show those in viewport
    const visibleElements = cachedElements.filter((element) => {
        // Check if element is in viewport
        const rect = element.rect;
        return !(rect.bottom <= 0 ||
            rect.top >= window.innerHeight ||
            rect.right <= 0 ||
            rect.left >= window.innerWidth);
    });
    console.log(`[HintDetector] Showing ${visibleElements.length} hints from ${cachedElements.length} cached elements`);
    visibleElements.forEach((element, visibleIndex) => {
        const marker = document.createElement("div");
        const hintLabel = String(visibleIndex); // Use the persistent ID
        marker.style.cssText = `
      position: fixed !important;
      left: ${element.rect.left}px !important;
      top: ${element.rect.top}px !important;
      background: linear-gradient(to bottom, #FFF785 0%, #FFC542 100%) !important;
      border: 1px solid #C38A22 !important;
      border-radius: 3px !important;
      box-shadow: 0px 3px 7px 0px rgba(0, 0, 0, 0.3) !important;
      color: #302505 !important;
      font-family: Helvetica, Arial, sans-serif !important;
      font-size: 11px !important;
      font-weight: bold !important;
      padding: 2px 5px !important;
      text-align: center !important;
      user-select: none !important;
      cursor: pointer !important;
      min-width: 16px !important;
      z-index: 2147483647 !important;
      pointer-events: auto !important;
    `;
        marker.textContent = hintLabel;
        marker.title = element.reason || element.text || element.href || "";
        // Store hint data on the marker for click handling
        marker.dataset.hintIndex = String(element.id);
        marker.dataset.hintXpath = element.xpath || "";
        // Add click handler to the marker
        marker.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            const elementId = parseInt(marker.dataset.hintIndex);
            console.log(`[HintDetector] Marker clicked for element ID ${elementId}`);
            // Use the existing clickElementById function which handles all the fallback logic
            clickElementById(elementId);
        });
        container.appendChild(marker);
    });
}
// Hide hint markers
function hideHints() {
    clearHints();
}
// Cache for persistent elements across AI interactions
let cachedElements = null;
let cacheViewportOnly = null;
// Get structured data for AI agent
function getInteractableElements(viewportOnly = true) {
    // Return cached elements if available and viewport setting matches
    if (cachedElements && cacheViewportOnly === viewportOnly) {
        console.log(`[HintDetector] Returning cached elements (${cachedElements.length} items)`);
        return cachedElements;
    }
    // Generate new elements and cache them
    console.log("[HintDetector] Generating new elements array for AI agent");
    const hints = detectHints(viewportOnly);
    cachedElements = hints.map((hint, index) => ({
        id: index + 1,
        type: determineElementType(hint),
        text: hint.linkText,
        href: hint.href,
        rect: hint.rect,
        reason: hint.reason,
        xpath: hint.xpath,
        selector: hint.selector || "",
    }));
    cacheViewportOnly = viewportOnly;
    console.log(`[HintDetector] Cached ${cachedElements.length} elements for AI agent`);
    return cachedElements;
}
// Explicitly refresh the cached elements (called by AI agent when needed)
function refreshInteractableElements(viewportOnly = true) {
    console.log("[HintDetector] Explicitly refreshing cached elements");
    cachedElements = null;
    cacheViewportOnly = null;
    return getInteractableElements(viewportOnly);
}
// Get DOM element by hint ID
function getElementByHintId(id) {
    const elements = getInteractableElements(false);
    const targetElement = elements[id - 1];
    if (!targetElement)
        return null;
    // Try CSS selector first
    if (targetElement.selector) {
        try {
            const element = document.querySelector(targetElement.selector);
            if (element) {
                console.log(`[HintDetector] Found element ${id} using CSS selector: ${targetElement.selector}`);
                return element;
            }
        }
        catch (error) {
            console.warn(`[HintDetector] CSS selector failed for element ${id}:`, error);
        }
    }
    // Fallback to XPath
    if (targetElement.xpath) {
        const element = evaluateXPath(targetElement.xpath);
        if (element) {
            console.log(`[HintDetector] Found element ${id} using XPath: ${targetElement.xpath}`);
            return element;
        }
    }
    // Final fallback to rectangle comparison
    console.log(`[HintDetector] CSS selector and XPath failed for element ${id}, falling back to rectangle comparison`);
    const allElements = getAllElements(document.documentElement);
    const element = findElementByRect(allElements, targetElement.rect, true);
    if (element) {
        console.log(`[HintDetector] Found element ${id} using rectangle comparison fallback`);
        return element;
    }
    console.warn(`[HintDetector] Failed to find element ${id} using all methods (CSS selector, XPath, and rectangle comparison)`);
    return null;
}
// Click element by ID (for AI agent)
function clickElementById(id) {
    const element = getElementByHintId(id);
    if (!element) {
        console.log(`[HintDetector] Failed to click element ${id}: element not found`);
        return false;
    }
    console.log(`[HintDetector] Clicking element ${id}`);
    executeClickAction(element);
    return true;
}
// Type text with proper event simulation
function typeTextById(id, text) {
    const element = getElementByHintId(id);
    if (!element)
        return { success: false, error: "Element not found" };
    if (element instanceof HTMLElement) {
        element.focus();
    }
    // Handle different input types
    if ("value" in element) {
        element.value = "";
        // Simulate typing each character
        for (const char of text) {
            element.value += char;
            element.dispatchEvent(new Event("input", { bubbles: true }));
        }
        dispatchInputEvents(element);
    }
    else if (element.isContentEditable) {
        element.textContent = text;
        element.dispatchEvent(new Event("input", { bubbles: true }));
    }
    return { success: true };
}
// Extract text using same logic as getLinkText
function getElementTextContent(id) {
    const element = getElementByHintId(id);
    if (!element)
        return "";
    return getLinkText(element);
}
// Get/Set element values for forms
function getElementValue(id) {
    const element = getElementByHintId(id);
    if (!element)
        return null;
    if ("value" in element)
        return element.value;
    if (element.isContentEditable)
        return element.textContent;
    return null;
}
function setElementValue(id, value) {
    const element = getElementByHintId(id);
    if (!element)
        return { success: false, error: "Element not found" };
    if ("value" in element) {
        element.value = value;
        dispatchInputEvents(element);
        return { success: true };
    }
    else if (element.isContentEditable) {
        element.textContent = value;
        element.dispatchEvent(new Event("input", { bubbles: true }));
        return { success: true };
    }
    return { success: false, error: "Element does not support value setting" };
}
// Hover action
function hoverElementById(id) {
    const element = getElementByHintId(id);
    if (!element)
        return { success: false, error: "Element not found" };
    const rect = element.getBoundingClientRect();
    const event = new MouseEvent("mouseover", {
        view: window,
        bubbles: true,
        cancelable: true,
        clientX: rect.left + rect.width / 2,
        clientY: rect.top + rect.height / 2,
    });
    element.dispatchEvent(event);
    return { success: true };
}
// Scroll to element
function scrollToElementById(id) {
    const element = getElementByHintId(id);
    if (!element)
        return { success: false, error: "Element not found" };
    element.scrollIntoView({ behavior: "smooth", block: "center" });
    return { success: true };
}
// Performance optimization utilities
function throttle(func, delay) {
    let lastCall = 0;
    let timeout;
    return ((...args) => {
        const now = Date.now();
        if (timeout)
            clearTimeout(timeout);
        if (now - lastCall >= delay) {
            lastCall = now;
            func(...args);
        }
        else {
            timeout = setTimeout(() => {
                lastCall = Date.now();
                func(...args);
            }, delay - (now - lastCall));
        }
    });
}
function debounce(func, delay) {
    let timeout;
    return ((...args) => {
        if (timeout)
            clearTimeout(timeout);
        timeout = setTimeout(() => func(...args), delay);
    });
}
// Initialize hint detector
(function () {
    // Make functions available globally
    window.detectHints = detectHints;
    window.showHints = showHints;
    window.hideHints = hideHints;
    window.getInteractableElements = getInteractableElements;
    window.refreshInteractableElements = refreshInteractableElements;
    window.clickElementById = clickElementById;
    window.getElementByHintId = getElementByHintId;
    window.typeTextById = typeTextById;
    window.getElementTextContent = getElementTextContent;
    window.getElementValue = getElementValue;
    window.setElementValue = setElementValue;
    window.hoverElementById = hoverElementById;
    window.scrollToElementById = scrollToElementById;
    // Use requestIdleCallback for periodic updates
    const refreshHintsIdle = () => {
        if ("requestIdleCallback" in window) {
            requestIdleCallback(() => {
                showHints();
            }, { timeout: 2000 });
        }
        else {
            setTimeout(() => showHints(), 2000);
        }
    };
    // Debounced refresh for mutations
    const refreshHintsDebounced = debounce(showHints, 100);
    // Throttled refresh for scroll/resize
    const refreshHintsThrottled = throttle(showHints, 150);
    // Auto-show hints when page loads and populate cache
    setTimeout(() => {
        console.log("[HintDetector] Initial page load - populating cache and showing hints");
        refreshInteractableElements(true); // Populate cache with full page elements
        showHints(); // Show visible hints
    }, 1000);
    // Use throttled refresh for scroll/resize events
    window.addEventListener("scroll", refreshHintsThrottled, { passive: true });
    window.addEventListener("resize", refreshHintsThrottled, { passive: true });
    // Set up mutation observer for dynamic content with debounced refresh
    const observer = new MutationObserver(() => {
        refreshHintsDebounced();
    });
    // Start observing the document for changes
    if (document.body) {
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ["style", "class", "hidden"],
        });
    }
    // Use requestIdleCallback for periodic updates
    const periodicRefresh = () => {
        refreshHintsIdle();
        // Schedule next refresh
        setTimeout(periodicRefresh, 5000);
    };
    setTimeout(periodicRefresh, 5000);
    console.log("[HintDetector] TypeScript hint detector initialized");
})();

})();
